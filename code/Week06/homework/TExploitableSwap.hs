{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where
import           Control.Monad        (replicateM)
import           Plutus.V2.Ledger.Api (PubKeyHash,Value,Txoutref)
import           Plutus.Model         (Run,
                                       TypedValidator (TypedValidator),UserSpend,
                                       adaValue, defaultBabbage, mustFail, testNoErrors,
                                       toV2, FakeCoin (FakeCoin), fakeValue,newUser,Ada (Lovelace),ada,Tx
                                       ,payToScript,DatumMode (HashDatum),userSpend)
import           PlutusTx.Prelude     (($), Integer)
import           Prelude              (IO, (.), (<>), undefined,mconcat)
import qualified ExploitableSwap      as OnChain
import           Test.Tasty           (defaultMain, testGroup)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO () -- running after cabal test <name of the test>
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" normalSpending
      , bad  "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------
-- Set many users at once
setupUsers :: Run [PubKeyHash]
setupUsers = replicateM 2 $ newUser $ ada (Lovelace 1000)

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

lockingTx :: PubKeyHash -> Integer -> Value -> UserSpend -> Tx
lockingTx ben int val usp = mconcat
    [  userSpend usp,
     payToScript swapScript (HashDatum (OnChain.DatumSwap ben int)) val
    ]

consumingTx :: PubKeyHash -> Integer -> PubKeyHash -> TxOutRef -> Value -> Tx
consumingTx = undefined

doubleConsumingTx :: a
doubleConsumingTx = undefined

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: Run ()
normalSpending = undefined


doubleSpending :: Run ()
doubleSpending = undefined